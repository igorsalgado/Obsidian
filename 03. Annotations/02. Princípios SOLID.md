---
Data: 2023-05-22
Hora: 23:04
---
``Tags:`` #Java #Backend #POO

---

## Resume

1.  Princípio da Responsabilidade Única (Single Responsibility Principle): Uma classe deve ter apenas uma única responsabilidade. Isso significa que uma classe deve ter apenas um motivo para mudar. Um exemplo em Java é a classe `Cliente` que tem a responsabilidade de representar um cliente e enviar e-mails relacionados a esse cliente.
    
2.  Princípio Aberto/Fechado (Open/Closed Principle): As entidades de software devem estar abertas para extensão, mas fechadas para modificação. Isso significa que você deve poder estender o comportamento de uma entidade sem precisar modificar seu código fonte. Um exemplo em Java é a classe abstrata `Forma`, que define o contrato do método `calcularArea()`, permitindo que classes como `Retangulo` e `Circulo` estendam esse comportamento sem modificar a classe `Forma`.
    
3.  Princípio da Substituição de Liskov (Liskov Substitution Principle): Um objeto de uma classe derivada deve poder ser substituído por um objeto de sua classe base sem quebrar a funcionalidade do programa. Isso significa que a classe derivada deve ser compatível com a classe base em termos de comportamento e contrato. Um exemplo em Java é a hierarquia de classes `Animal`, onde as classes derivadas `Cachorro` e `Gato` podem ser substituídas pela classe base `Animal` sem causar problemas de funcionalidade.


## Content

#### S - Princípio da Responsabilidade Única

O Princípio da Responsabilidade Única afirma que uma classe deve ter apenas uma única responsabilidade. Em outras palavras, uma classe deve ter apenas um motivo para mudar. Isso ajuda a manter o código mais coeso e facilita a compreensão e a manutenção do mesmo.

```java
public class Cliente{ 
	private String nome;
	private String email;

public Cliente(String nome, String email) {
	this.nome = nome;
	this.email = email; 
} 

	public void enviarEmail(String mensagem) {
// Lógica para enviar o e-mail 
	} 
}
```

Neste exemplo, a classe `Cliente` tem a responsabilidade de representar um cliente e também de enviar e-mails relacionados a esse cliente. Essas duas responsabilidades são mantidas separadas, seguindo o princípio da responsabilidade única.

#### O - Princípio Aberto/Fechado

O Princípio Aberto/Fechado afirma que as entidades de software devem estar abertas para extensão, mas fechadas para modificação. Isso significa que você deve poder estender o comportamento de uma entidade sem precisar modificar seu código fonte. Isso promove a reutilização de código e reduz o impacto de alterações em outras partes do sistema.

```java
public abstract class Forma {
	public abstract double calcularArea();
}

public class Retangulo extends Forma {
	private double largura;
	private double altura;

	public Retangulo(double largura, double altura) {
		this.largula = largura;
		this.altura = altura;
	}

	@Override
	public double calcularArea() {
	return largula * altura
	}
}

public class Circulo extends Forma {
	private double raio;

	public Circulo(double raio) {
		this.raio = raio;
	}

	@Override
	public double CalcularArea() {
		return Math.PI * raio * raio;
	}	
}
```

Neste exemplo, a classe abstrata `Forma` define um contrato com o método `calcularArea()`, permitindo que outras classes, como `Retangulo` e `Circulo`, estendam esse comportamento sem modificar o código da classe `Forma`. Isso nos permite adicionar facilmente novas formas geométricas sem alterar o código existente.

## L - Princípio da Substituição de Liskov (Liskov Substitution Principle)

O Princípio da Substituição de Liskov afirma que um objeto de uma classe derivada deve poder ser substituído por um objeto de sua classe base sem quebrar a funcionalidade do programa. Isso significa que a classe derivada deve ser compatível com a classe base em termos de comportamento e contrato.

```java
public abstract class Animal {
    public abstract void fazerBarulho();
}

public class Cachorro extends Animal {
    @Override
    public void fazerBarulho() {
        System.out.println("Au Au!");
    }
}

public class Gato extends Animal {
    @Override
    public void fazerBarulho() {
        System.out.println("Miau!");
    }
}
```

Neste exemplo, a classe abstrata `Animal` define um contrato com o método `fazerBarulho()`. As classes derivadas `Cachorro` e `Gato` implementam esse método de acordo com o comportamento esperado para cada animal. Podemos tratar objetos do tipo `Cachorro` e `Gato` de forma polimórfica como objetos do tipo `Animal`, garantindo a substituição de Liskov.


## Conclusão

Esses princípios SOLID fornecem diretrizes valiosas para escrever código de qualidade, flexível e de fácil manutenção. Ao aplicar esses princípios em seus projetos Java, você pode criar um software mais robusto e escalável.

## References
- []
- []
